# requirements.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
alembic==1.13.1
psycopg2-binary==2.9.9
python-jose[cryptography]==3.3.0
python-multipart==0.0.6
passlib[bcrypt]==1.7.4
pydantic==2.5.0
pydantic-settings==2.1.0
python-dateutil==2.8.2
redis==5.0.1
celery==5.3.4
openpyxl==3.1.2
reportlab==4.0.7
pandas==2.1.4
pytest==7.4.3
pytest-asyncio==0.21.1
httpx==0.25.2

# main.py
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from datetime import datetime, timedelta
import os
from typing import List, Optional
import uvicorn

from database import get_db, engine
from models import Base
from auth import get_current_user, get_current_admin_user
from schemas import *
from crud import *

# Create tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="TEAM BIOINFO API", version="1.0.0")

# CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

security = HTTPBearer()

# Auth endpoints
@app.post("/auth/register", response_model=UserResponse)
async def register(user_data: UserCreate, db: Session = Depends(get_db)):
    return create_user(db, user_data)

@app.post("/auth/login", response_model=TokenResponse)
async def login(credentials: UserLogin, db: Session = Depends(get_db)):
    return authenticate_user(db, credentials.email, credentials.password)

@app.post("/auth/refresh", response_model=TokenResponse)
async def refresh_token(token_data: RefreshTokenRequest, db: Session = Depends(get_db)):
    return refresh_access_token(db, token_data.refresh_token)

@app.post("/auth/logout")
async def logout(current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return {"message": "Logged out successfully"}

# User management (Admin only)
@app.get("/users", response_model=List[UserResponse])
async def get_users(current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return get_all_users(db)

@app.put("/users/{user_id}/role")
async def update_user_role(user_id: int, role_data: UserRoleUpdate, 
                          current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return update_user_role_crud(db, user_id, role_data.role)

@app.delete("/users/{user_id}")
async def delete_user(user_id: int, current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return delete_user_crud(db, user_id)

# Team management
@app.post("/teams", response_model=TeamResponse)
async def create_team(team_data: TeamCreate, current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return create_team_crud(db, team_data, current_admin["user_id"])

@app.get("/teams", response_model=List[TeamResponse])
async def get_teams(current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return get_all_teams(db)

@app.put("/teams/{team_id}/members")
async def update_team_members(team_id: int, member_data: TeamMemberUpdate,
                             current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return update_team_members_crud(db, team_id, member_data.member_ids)

# Work entries
@app.post("/work-entries", response_model=WorkEntryResponse)
async def create_work_entry(entry_data: WorkEntryCreate, current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return create_work_entry_crud(db, entry_data, current_user["user_id"])

@app.get("/work-entries", response_model=List[WorkEntryResponse])
async def get_work_entries(date: Optional[str] = None, user_id: Optional[int] = None,
                          current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return get_work_entries_crud(db, current_user, date, user_id)

@app.put("/work-entries/{entry_id}")
async def update_work_entry(entry_id: int, entry_data: WorkEntryUpdate,
                           current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return update_work_entry_crud(db, entry_id, entry_data, current_user["user_id"])

@app.post("/work-entries/{entry_id}/approve")
async def approve_work_entry(entry_id: int, current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return approve_work_entry_crud(db, entry_id, current_admin["user_id"])

# Task allocation
@app.post("/tasks", response_model=TaskResponse)
async def create_task(task_data: TaskCreate, current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return create_task_crud(db, task_data, current_user["user_id"])

@app.get("/tasks", response_model=List[TaskResponse])
async def get_tasks(assigned_to: Optional[int] = None, current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return get_tasks_crud(db, current_user, assigned_to)

@app.put("/tasks/{task_id}/progress")
async def update_task_progress(task_id: int, progress_data: TaskProgressUpdate,
                              current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return update_task_progress_crud(db, task_id, progress_data, current_user["user_id"])

# Dashboard and analytics
@app.get("/dashboard/daily")
async def get_daily_dashboard(date: Optional[str] = None, current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return get_daily_dashboard_crud(db, current_user, date)

@app.get("/dashboard/team/{team_id}")
async def get_team_dashboard(team_id: int, start_date: Optional[str] = None, end_date: Optional[str] = None,
                            current_user: dict = Depends(get_current_user), db: Session = Depends(get_db)):
    return get_team_dashboard_crud(db, team_id, current_user, start_date, end_date)

@app.get("/dashboard/performance")
async def get_performance_analytics(current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return get_performance_analytics_crud(db)

# Reports and exports
@app.get("/reports/export")
async def export_data(format: str, start_date: str, end_date: str, team_id: Optional[int] = None,
                     current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return export_work_data_crud(db, format, start_date, end_date, team_id)

@app.get("/backup/daily")
async def create_daily_backup(current_admin: dict = Depends(get_current_admin_user), db: Session = Depends(get_db)):
    return create_backup_crud(db, "daily")

# Health check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "timestamp": datetime.utcnow()}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)

# database.py
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL", "postgresql://bioinfo_user:bioinfo_pass@localhost/team_bioinfo_db")

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# models.py
from sqlalchemy import Column, Integer, String, DateTime, Float, Boolean, Text, ForeignKey, Enum, JSON
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base
import enum

class UserRole(enum.Enum):
    ADMIN = "admin"
    TEAM_LEAD = "team_lead"
    MEMBER = "member"

class TaskStatus(enum.Enum):
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    ON_HOLD = "on_hold"

class TaskPriority(enum.Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class ApprovalStatus(enum.Enum):
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    username = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String, nullable=False)
    hashed_password = Column(String, nullable=False)
    role = Column(Enum(UserRole), default=UserRole.MEMBER)
    team_id = Column(Integer, ForeignKey("teams.id"), nullable=True)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    team = relationship("Team", back_populates="members")
    work_entries = relationship("WorkEntry", back_populates="user")
    created_tasks = relationship("Task", foreign_keys="Task.created_by", back_populates="creator")
    assigned_tasks = relationship("Task", foreign_keys="Task.assigned_to", back_populates="assignee")
    audit_logs = relationship("AuditLog", back_populates="user")

class Team(Base):
    __tablename__ = "teams"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, nullable=False)
    description = Column(Text)
    team_lead_id = Column(Integer, ForeignKey("users.id"), nullable=True)
    created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    members = relationship("User", back_populates="team")
    team_lead = relationship("User", foreign_keys=[team_lead_id])
    creator = relationship("User", foreign_keys=[created_by])

class WorkEntry(Base):
    __tablename__ = "work_entries"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    date = Column(DateTime, nullable=False)
    
    # Work categories with hours
    tasks = Column(Text)
    total_hours = Column(Float, nullable=False)
    category = Column(String, nullable=False)
    status = Column(String, default="in_progress")
    notes = Column(Text)
    
    # Bioinformatics specific fields
    tertiary_analysis_hours = Column(Float, default=0.0)
    cnv_analysis_hours = Column(Float, default=0.0)
    report_preparation_hours = Column(Float, default=0.0)
    report_rework_hours = Column(Float, default=0.0)
    report_crosscheck_hours = Column(Float, default=0.0)
    report_allocation_hours = Column(Float, default=0.0)
    gene_panel_coverage_hours = Column(Float, default=0.0)
    
    # Approval system
    approval_status = Column(Enum(ApprovalStatus), default=ApprovalStatus.PENDING)
    approved_by = Column(Integer, ForeignKey("users.id"), nullable=True)
    approved_at = Column(DateTime, nullable=True)
    
    # Time tracking
    estimated_hours = Column(Float, nullable=True)
    actual_hours = Column(Float, nullable=True)
    
    is_locked = Column(Boolean, default=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    user = relationship("User", back_populates="work_entries")
    approver = relationship("User", foreign_keys=[approved_by])

class Task(Base):
    __tablename__ = "tasks"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, nullable=False)
    description = Column(Text)
    assigned_to = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_by = Column(Integer, ForeignKey("users.id"), nullable=False)
    team_id = Column(Integer, ForeignKey("teams.id"), nullable=True)
    
    priority = Column(Enum(TaskPriority), default=TaskPriority.MEDIUM)
    status = Column(Enum(TaskStatus), default=TaskStatus.NOT_STARTED)
    
    estimated_hours = Column(Float, nullable=True)
    actual_hours = Column(Float, default=0.0)
    
    due_date = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    # Progress tracking
    progress_percentage = Column(Integer, default=0)
    checklist_items = Column(JSON, nullable=True)  # [{"item": "task", "completed": false}]
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    assignee = relationship("User", foreign_keys=[assigned_to], back_populates="assigned_tasks")
    creator = relationship("User", foreign_keys=[created_by], back_populates="created_tasks")
    team = relationship("Team")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    action = Column(String, nullable=False)
    resource_type = Column(String, nullable=False)
    resource_id = Column(Integer, nullable=True)
    old_values = Column(JSON, nullable=True)
    new_values = Column(JSON, nullable=True)
    ip_address = Column(String, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User", back_populates="audit_logs")

class BackupRecord(Base):
    __tablename__ = "backup_records"
    
    id = Column(Integer, primary_key=True, index=True)
    backup_type = Column(String, nullable=False)  # daily, weekly, monthly
    file_path = Column(String, nullable=False)
    file_size = Column(Integer, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

# schemas.py
from pydantic import BaseModel, EmailStr, validator
from datetime import datetime
from typing import Optional, List, Dict, Any
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    TEAM_LEAD = "team_lead"
    MEMBER = "member"

class TaskStatus(str, Enum):
    NOT_STARTED = "not_started"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    ON_HOLD = "on_hold"

class TaskPriority(str, Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

class ApprovalStatus(str, Enum):
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"

# User schemas
class UserCreate(BaseModel):
    email: EmailStr
    username: str
    full_name: str
    password: str
    role: Optional[UserRole] = UserRole.MEMBER

class UserLogin(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    id: int
    email: str
    username: str
    full_name: str
    role: UserRole
    team_id: Optional[int] = None
    is_active: bool
    created_at: datetime

    class Config:
        from_attributes = True

class UserRoleUpdate(BaseModel):
    role: UserRole

class TokenResponse(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"
    expires_in: int

class RefreshTokenRequest(BaseModel):
    refresh_token: str

# Team schemas
class TeamCreate(BaseModel):
    name: str
    description: Optional[str] = None
    team_lead_id: Optional[int] = None

class TeamResponse(BaseModel):
    id: int
    name: str
    description: Optional[str]
    team_lead_id: Optional[int]
    created_by: int
    created_at: datetime
    members: List[UserResponse] = []

    class Config:
        from_attributes = True

class TeamMemberUpdate(BaseModel):
    member_ids: List[int]

# Work entry schemas
class WorkEntryCreate(BaseModel):
    date: datetime
    tasks: str
    total_hours: float
    category: str
    status: str = "in_progress"
    notes: Optional[str] = None
    tertiary_analysis_hours: float = 0.0
    cnv_analysis_hours: float = 0.0
    report_preparation_hours: float = 0.0
    report_rework_hours: float = 0.0
    report_crosscheck_hours: float = 0.0
    report_allocation_hours: float = 0.0
    gene_panel_coverage_hours: float = 0.0
    estimated_hours: Optional[float] = None

    @validator('total_hours', 'tertiary_analysis_hours', 'cnv_analysis_hours', 
              'report_preparation_hours', 'report_rework_hours', 'report_crosscheck_hours',
              'report_allocation_hours', 'gene_panel_coverage_hours')
    def validate_hours(cls, v):
        if v < 0 or v > 24:
            raise ValueError('Hours must be between 0 and 24')
        return v

class WorkEntryUpdate(BaseModel):
    tasks: Optional[str] = None
    total_hours: Optional[float] = None
    category: Optional[str] = None
    status: Optional[str] = None
    notes: Optional[str] = None
    tertiary_analysis_hours: Optional[float] = None
    cnv_analysis_hours: Optional[float] = None
    report_preparation_hours: Optional[float] = None
    report_rework_hours: Optional[float] = None
    report_crosscheck_hours: Optional[float] = None
    report_allocation_hours: Optional[float] = None
    gene_panel_coverage_hours: Optional[float] = None
    estimated_hours: Optional[float] = None

class WorkEntryResponse(BaseModel):
    id: int
    user_id: int
    date: datetime
    tasks: str
    total_hours: float
    category: str
    status: str
    notes: Optional[str]
    tertiary_analysis_hours: float
    cnv_analysis_hours: float
    report_preparation_hours: float
    report_rework_hours: float
    report_crosscheck_hours: float
    report_allocation_hours: float
    gene_panel_coverage_hours: float
    approval_status: ApprovalStatus
    approved_by: Optional[int]
    approved_at: Optional[datetime]
    estimated_hours: Optional[float]
    actual_hours: Optional[float]
    is_locked: bool
    created_at: datetime
    updated_at: Optional[datetime]

    class Config:
        from_attributes = True

# Task schemas
class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = None
    assigned_to: int
    team_id: Optional[int] = None
    priority: TaskPriority = TaskPriority.MEDIUM
    estimated_hours: Optional[float] = None
    due_date: Optional[datetime] = None
    checklist_items: Optional[List[Dict[str, Any]]] = None

class TaskProgressUpdate(BaseModel):
    status: Optional[TaskStatus] = None
    progress_percentage: Optional[int] = None
    actual_hours: Optional[float] = None
    checklist_items: Optional[List[Dict[str, Any]]] = None

class TaskResponse(BaseModel):
    id: int
    title: str
    description: Optional[str]
    assigned_to: int
    created_by: int
    team_id: Optional[int]
    priority: TaskPriority
    status: TaskStatus
    estimated_hours: Optional[float]
    actual_hours: float
    due_date: Optional[datetime]
    completed_at: Optional[datetime]
    progress_percentage: int
    checklist_items: Optional[List[Dict[str, Any]]]
    created_at: datetime
    updated_at: Optional[datetime]

    class Config:
        from_attributes = True

# auth.py
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session
from database import get_db
from models import User, UserRole

SECRET_KEY = "your-secret-key-change-this-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
REFRESH_TOKEN_EXPIRE_DAYS = 7

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
security = HTTPBearer()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode.update({"exp": expire, "type": "refresh"})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), db: Session = Depends(get_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.email == email).first()
    if user is None:
        raise credentials_exception
    
    return {"user_id": user.id, "email": user.email, "role": user.role, "team_id": user.team_id}

async def get_current_admin_user(current_user: dict = Depends(get_current_user)):
    if current_user["role"] not in [UserRole.ADMIN, UserRole.TEAM_LEAD]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions"
        )
    return current_user

# crud.py
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_, func, extract
from models import *
from schemas import *
from auth import get_password_hash, verify_password, create_access_token, create_refresh_token
from datetime import datetime, timedelta, date
import pandas as pd
import os
from typing import List, Optional, Dict, Any
import json

def create_user(db: Session, user_data: UserCreate):
    # Check if user exists
    if db.query(User).filter(User.email == user_data.email).first():
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed_password = get_password_hash(user_data.password)
    db_user = User(
        email=user_data.email,
        username=user_data.username,
        full_name=user_data.full_name,
        hashed_password=hashed_password,
        role=user_data.role
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    
    # Create audit log
    create_audit_log(db, db_user.id, "CREATE", "user", db_user.id, None, {"email": user_data.email})
    
    return db_user

def authenticate_user(db: Session, email: str, password: str):
    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password"
        )
    
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    refresh_token = create_refresh_token(data={"sub": user.email})
    
    # Create audit log
    create_audit_log(db, user.id, "LOGIN", "auth", None, None, {"timestamp": datetime.utcnow()})
    
    return {
        "access_token": access_token,
        "refresh_token": refresh_token,
        "token_type": "bearer",
        "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
    }

def refresh_access_token(db: Session, refresh_token: str):
    try:
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        token_type: str = payload.get("type")
        
        if email is None or token_type != "refresh":
            raise HTTPException(status_code=401, detail="Invalid refresh token")
        
        user = db.query(User).filter(User.email == email).first()
        if user is None:
            raise HTTPException(status_code=401, detail="User not found")
        
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        access_token = create_access_token(
            data={"sub": user.email}, expires_delta=access_token_expires
        )
        new_refresh_token = create_refresh_token(data={"sub": user.email})
        
        return {
            "access_token": access_token,
            "refresh_token": new_refresh_token,
            "token_type": "bearer",
            "expires_in": ACCESS_TOKEN_EXPIRE_MINUTES * 60
        }
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid refresh token")

def get_all_users(db: Session):
    return db.query(User).filter(User.is_active == True).all()

def update_user_role_crud(db: Session, user_id: int, role: UserRole):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    old_role = user.role
    user.role = role
    db.commit()
    
    create_audit_log(db, user.id, "UPDATE", "user_role", user_id, {"role": old_role}, {"role": role})
    return {"message": "User role updated successfully"}

def delete_user_crud(db: Session, user_id: int):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    user.is_active = False
    db.commit()
    
    create_audit_log(db, user.id, "DELETE", "user", user_id, {"is_active": True}, {"is_active": False})
    return {"message": "User deactivated successfully"}

# Team management
def create_team_crud(db: Session, team_data: TeamCreate, created_by: int):
    db_team = Team(
        name=team_data.name,
        description=team_data.description,
        team_lead_id=team_data.team_lead_id,
        created_by=created_by
    )
    db.add(db_team)
    db.commit()
    db.refresh(db_team)
    
    create_audit_log(db, created_by, "CREATE", "team", db_team.id, None, {"name": team_data.name})
    return db_team

def get_all_teams(db: Session):
    return db.query(Team).all()

def update_team_members_crud(db: Session, team_id: int, member_ids: List[int]):
    team = db.query(Team).filter(Team.id == team_id).first()
    if not team:
        raise HTTPException(status_code=404, detail="Team not found")
    
    # Update team members
    db.query(User).filter(User.team_id == team_id).update({"team_id": None})
    db.query(User).filter(User.id.in_(member_ids)).update({"team_id": team_id})
    db.commit()
    
    create_audit_log(db, None, "UPDATE", "team_members", team_id, None, {"member_ids": member_ids})
    return {"message": "Team members updated successfully"}

# Work entries
def create_work_entry_crud(db: Session, entry_data: WorkEntryCreate, user_id: int):
    # Check if entry already exists for this date
    existing_entry = db.query(WorkEntry).filter(
        and_(WorkEntry.user_id == user_id, func.date(WorkEntry.date) == entry_data.date.date())
    ).first()
    
    if existing_entry:
        raise HTTPException(status_code=400, detail="Work entry already exists for this date")
    
    db_entry = WorkEntry(
        user_id=user_id,
        date=entry_data.date,
        tasks=entry_data.tasks,
        total_hours=entry_data.total_hours,
        category=entry_data.category,
        status=entry_data.status,
        notes=entry_data.notes,
        tertiary_analysis_hours=entry_data.tertiary_analysis_hours,
        cnv_analysis_hours=entry_data.cnv_analysis_hours,
        report_preparation_hours=entry_data.report_preparation_hours,
        report_rework_hours=entry_data.report_rework_hours,
        report_crosscheck_hours=entry_data.report_crosscheck_hours,
        report_allocation_hours=entry_data.report_allocation_hours,
        gene_panel_coverage_hours=entry_data.gene_panel_coverage_hours,
        estimated_hours=entry_data.estimated_hours,
        actual_hours=entry_data.total_hours
    )
    db.add(db_entry)
    db.commit()
    db.refresh(db_entry)
    
    create_audit_log(db, user_id, "CREATE", "work_entry", db_entry.id, None, {"date": entry_data.date.isoformat()})
    return db_entry

def get_work_entries_crud(db: Session, current_user: dict, date: Optional[str] = None, user_id: Optional[int] = None):
    query = db.query(WorkEntry)
    
    # Role-based filtering
    if current_user["role"] == UserRole.MEMBER:
        query = query.filter(WorkEntry.user_id == current_user["user_id"])
    elif current_user["role"] == UserRole.TEAM_LEAD:
        # Team leads can see their team's entries
        team_member_ids = db.query(User.id).filter(User.team_id == current_user["team_id"]).all()
        team_member_ids = [id[0] for id in team_member_ids]
        query = query.filter(WorkEntry.user_id.in_(team_member_ids))
    
    if date:
        target_date = datetime.fromisoformat(date).date()
        query = query.filter(func.date(WorkEntry.date) == target_date)
    
    if user_id and current_user["role"] in [UserRole.ADMIN, UserRole.TEAM_LEAD]:
        query = query.filter(WorkEntry.user_id == user_id)
    
    return query.order_by(WorkEntry.date.desc()).all()

def update_work_entry_crud(db: Session, entry_id: int, entry_data: WorkEntryUpdate, user_id: int):
    entry = db.query(WorkEntry).filter(WorkEntry.id == entry_id).first()
    if not entry:
        raise HTTPException(status_code=404, detail="Work entry not found")
    
    if entry.is_locked:
        raise HTTPException(status_code=400, detail="Work entry is locked and cannot be modified")
    
    if entry.user_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized to update this entry")
    
    old_values = {
        "tasks": entry.tasks,
        "total_hours": entry.total_hours,
        "category": entry.category,
        "status": entry.status
    }
    
    # Update fields
    for field, value in entry_data.dict(exclude_unset=True).items():
        setattr(entry, field, value)
    
    db.commit()
    db.refresh(entry)
    
    create_audit_log(db, user_id, "UPDATE", "work_entry", entry_id, old_values, entry_data.dict(exclude_unset=True))
    return entry

def approve_work_entry_crud(db: Session, entry_id: int, admin_id: int):
    entry = db.query(WorkEntry).filter(WorkEntry.id == entry_id).first()
    if not entry:
        raise HTTPException(status_code=404, detail="Work entry not found")
    
    entry.approval_status = ApprovalStatus.APPROVED
    entry.approved_by = admin_id
    entry.approved_at = datetime.utcnow()
    entry.is_locked = True
    
    db.commit()
    
    create_audit_log(db, admin_id, "APPROVE", "work_entry", entry_id, 
                    {"approval_status": "pending"}, {"approval_status": "approved"})
    return {"message": "Work entry approved successfully"}

# Task management
def create_task_crud(db: Session, task_data: TaskCreate, created_by: int):
    db_task = Task(
        title=task_data.title,
        description=task_data.description,
        assigned_to=task_data.assigned_to,
        created_by=created_by,
        team_id=task_data.team_id,
        priority=task_data.priority,
        estimated_hours=task_data.estimated_hours,
        due_date=task_data.due_date,
        checklist_items=task_data.checklist_items or []
    )
    db.add(db_task)
    db.commit()
    db.refresh(db_task)
    
    create_audit_log(db, created_by, "CREATE", "task", db_task.id, None, {"title": task_data.title})
    return db_task

def get_tasks_crud(db: Session, current_user: dict, assigned_to: Optional[int] = None):
    query = db.query(Task)
    
    if current_user["role"] == UserRole.MEMBER:
        query = query.filter(Task.assigned_to == current_user["user_id"])
    elif current_user["role"] == UserRole.TEAM_LEAD:
        team_member_ids = db.query(User.id).filter(User.team_id == current_user["team_id"]).all()
        team_member_ids = [id[0] for id in team_member_ids]
        query = query.filter(or_(Task.assigned_to.in_(team_member_ids), Task.created_by == current_user["user_id"]))
    
    if assigned_to and current_user["role"] in [UserRole.ADMIN, UserRole.TEAM_LEAD]:
        query = query.filter(Task.assigned_to == assigned_to)
    
    return query.order_by(Task.created_at.desc()).all()

def update_task_progress_crud(db: Session, task_id: int, progress_data: TaskProgressUpdate, user_id: int):
    task = db.query(Task).filter(Task.id == task_id).first()
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task.assigned_to != user_id and task.created_by != user_id:
        raise HTTPException(status_code=403, detail="Not authorized to update this task")
    
    old_values = {"status": task.status, "progress_percentage": task.progress_percentage}
    
    for field, value in progress_data.dict(exclude_unset=True).items():
        setattr(task, field, value)
    
    if progress_data.status == TaskStatus.COMPLETED:
        task.completed_at = datetime.utcnow()
        task.progress_percentage = 100
    
    db.commit()
    db.refresh(task)
    
    create_audit_log(db, user_id, "UPDATE", "task_progress", task_id, old_values, progress_data.dict(exclude_unset=True))
    return task

# Dashboard analytics
def get_daily_dashboard_crud(db: Session, current_user: dict, date: Optional[str] = None):
    target_date = datetime.fromisoformat(date).date() if date else datetime.now().date()
    
    # Base query for work entries
    query = db.query(WorkEntry).filter(func.date(WorkEntry.date) == target_date)
    
    if current_user["role"] == UserRole.MEMBER:
        query = query.filter(WorkEntry.user_id == current_user["user_id"])
    elif current_user["role"] == UserRole.TEAM_LEAD:
        team_member_ids = db.query(User.id).filter(User.team_id == current_user["team_id"]).all()
        team_member_ids = [id[0] for id in team_member_ids]
        query = query.filter(WorkEntry.user_id.in_(team_member_ids))
    
    entries = query.all()
    
    # Calculate metrics
    total_hours = sum(entry.total_hours for entry in entries)
    total_entries = len(entries)
    approved_entries = len([e for e in entries if e.approval_status == ApprovalStatus.APPROVED])
    pending_entries = len([e for e in entries if e.approval_status == ApprovalStatus.PENDING])
    
    # Category breakdown
    category_hours = {}
    for entry in entries:
        category_hours["tertiary_analysis"] = category_hours.get("tertiary_analysis", 0) + entry.tertiary_analysis_hours
        category_hours["cnv_analysis"] = category_hours.get("cnv_analysis", 0) + entry.cnv_analysis_hours
        category_hours["report_preparation"] = category_hours.get("report_preparation", 0) + entry.report_preparation_hours
        category_hours["report_rework"] = category_hours.get("report_rework", 0) + entry.report_rework_hours
        category_hours["report_crosscheck"] = category_hours.get("report_crosscheck", 0) + entry.report_crosscheck_hours
        category_hours["report_allocation"] = category_hours.get("report_allocation", 0) + entry.report_allocation_hours
        category_hours["gene_panel_coverage"] = category_hours.get("gene_panel_coverage", 0) + entry.gene_panel_coverage_hours
    
    return {
        "date": target_date.isoformat(),
        "total_hours": total_hours,
        "total_entries": total_entries,
        "approved_entries": approved_entries,
        "pending_entries": pending_entries,
        "category_breakdown": category_hours,
        "entries": entries
    }

def get_team_dashboard_crud(db: Session, team_id: int, current_user: dict, start_date: Optional[str] = None, end_date: Optional[str] = None):
    start_dt = datetime.fromisoformat(start_date) if start_date else datetime.now() - timedelta(days=30)
    end_dt = datetime.fromisoformat(end_date) if end_date else datetime.now()
    
    team_member_ids = db.query(User.id).filter(User.team_id == team_id).all()
    team_member_ids = [id[0] for id in team_member_ids]
    
    entries = db.query(WorkEntry).filter(
        and_(
            WorkEntry.user_id.in_(team_member_ids),
            WorkEntry.date >= start_dt,
            WorkEntry.date <= end_dt
        )
    ).all()
    
    # Team analytics
    total_hours = sum(entry.total_hours for entry in entries)
    avg_daily_hours = total_hours / max(1, (end_dt - start_dt).days + 1)
    
    # Member performance
    member_stats = {}
    for entry in entries:
        user_id = entry.user_id
        if user_id not in member_stats:
            member_stats[user_id] = {"total_hours": 0, "entries": 0, "categories": {}}
        
        member_stats[user_id]["total_hours"] += entry.total_hours
        member_stats[user_id]["entries"] += 1
    
    return {
        "team_id": team_id,
        "period": {"start": start_dt.isoformat(), "end": end_dt.isoformat()},
        "total_hours": total_hours,
        "avg_daily_hours": avg_daily_hours,
        "member_performance": member_stats,
        "entries": entries
    }

def get_performance_analytics_crud(db: Session):
    # Get last 30 days data
    thirty_days_ago = datetime.now() - timedelta(days=30)
    
    entries = db.query(WorkEntry).filter(WorkEntry.date >= thirty_days_ago).all()
    
    # Overall metrics
    total_hours = sum(entry.total_hours for entry in entries)
    total_entries = len(entries)
    avg_hours_per_entry = total_hours / max(1, total_entries)
    
    # Team performance
    teams = db.query(Team).all()
    team_performance = []
    
    for team in teams:
        team_entries = [e for e in entries if e.user.team_id == team.id]
        team_hours = sum(e.total_hours for e in team_entries)
        team_performance.append({
            "team_id": team.id,
            "team_name": team.name,
            "total_hours": team_hours,
            "entries_count": len(team_entries),
            "avg_hours": team_hours / max(1, len(team_entries))
        })
    
    # Top performers
    user_performance = {}
    for entry in entries:
        user_id = entry.user_id
        if user_id not in user_performance:
            user_performance[user_id] = {"total_hours": 0, "entries": 0}
        user_performance[user_id]["total_hours"] += entry.total_hours
        user_performance[user_id]["entries"] += 1
    
    top_performers = sorted(user_performance.items(), 
                           key=lambda x: x[1]["total_hours"], reverse=True)[:10]
    
    return {
        "period_days": 30,
        "total_hours": total_hours,
        "total_entries": total_entries,
        "avg_hours_per_entry": avg_hours_per_entry,
        "team_performance": team_performance,
        "top_performers": top_performers
    }

# Export and backup
def export_work_data_crud(db: Session, format: str, start_date: str, end_date: str, team_id: Optional[int] = None):
    start_dt = datetime.fromisoformat(start_date)
    end_dt = datetime.fromisoformat(end_date)
    
    query = db.query(WorkEntry).filter(
        and_(WorkEntry.date >= start_dt, WorkEntry.date <= end_dt)
    )
    
    if team_id:
        team_member_ids = db.query(User.id).filter(User.team_id == team_id).all()
        team_member_ids = [id[0] for id in team_member_ids]
        query = query.filter(WorkEntry.user_id.in_(team_member_ids))
    
    entries = query.all()
    
    # Prepare data for export
    export_data = []
    for entry in entries:
        export_data.append({
            "Date": entry.date.strftime("%Y-%m-%d"),
            "User": entry.user.full_name,
            "Team": entry.user.team.name if entry.user.team else "No Team",
            "Tasks": entry.tasks,
            "Total Hours": entry.total_hours,
            "Category": entry.category,
            "Status": entry.status,
            "Tertiary Analysis": entry.tertiary_analysis_hours,
            "CNV Analysis": entry.cnv_analysis_hours,
            "Report Preparation": entry.report_preparation_hours,
            "Report Rework": entry.report_rework_hours,
            "Report Crosscheck": entry.report_crosscheck_hours,
            "Report Allocation": entry.report_allocation_hours,
            "Gene Panel Coverage": entry.gene_panel_coverage_hours,
            "Approval Status": entry.approval_status.value,
            "Notes": entry.notes or ""
        })
    
    # Create export file
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"bioinfo_export_{timestamp}"
    
    if format.lower() == "csv":
        df = pd.DataFrame(export_data)
        file_path = f"/app/exports/{filename}.csv"
        df.to_csv(file_path, index=False)
    elif format.lower() == "xlsx":
        df = pd.DataFrame(export_data)
        file_path = f"/app/exports/{filename}.xlsx"
        df.to_excel(file_path, index=False)
    elif format.lower() == "tsv":
        df = pd.DataFrame(export_data)
        file_path = f"/app/exports/{filename}.tsv"
        df.to_csv(file_path, sep='\t', index=False)
    
    return {"file_path": file_path, "filename": f"{filename}.{format.lower()}"}

def create_backup_crud(db: Session, backup_type: str):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Get all data
    users = db.query(User).all()
    teams = db.query(Team).all()
    work_entries = db.query(WorkEntry).all()
    tasks = db.query(Task).all()
    
    backup_data = {
        "backup_info": {
            "timestamp": timestamp,
            "type": backup_type,
            "total_users": len(users),
            "total_entries": len(work_entries),
            "total_tasks": len(tasks)
        },
        "users": [{"id": u.id, "email": u.email, "full_name": u.full_name, "role": u.role.value} for u in users],
        "teams": [{"id": t.id, "name": t.name, "description": t.description} for t in teams],
        "work_entries": [],
        "tasks": []
    }
    
    # Add work entries data
    for entry in work_entries:
        backup_data["work_entries"].append({
            "id": entry.id,
            "user_id": entry.user_id,
            "date": entry.date.isoformat(),
            "tasks": entry.tasks,
            "total_hours": entry.total_hours,
            "category": entry.category,
            "status": entry.status,
            "tertiary_analysis_hours": entry.tertiary_analysis_hours,
            "cnv_analysis_hours": entry.cnv_analysis_hours,
            "report_preparation_hours": entry.report_preparation_hours,
            "report_rework_hours": entry.report_rework_hours,
            "report_crosscheck_hours": entry.report_crosscheck_hours,
            "report_allocation_hours": entry.report_allocation_hours,
            "gene_panel_coverage_hours": entry.gene_panel_coverage_hours,
            "approval_status": entry.approval_status.value,
            "notes": entry.notes
        })
    
    # Add tasks data
    for task in tasks:
        backup_data["tasks"].append({
            "id": task.id,
            "title": task.title,
            "description": task.description,
            "assigned_to": task.assigned_to,
            "created_by": task.created_by,
            "status": task.status.value,
            "priority": task.priority.value,
            "progress_percentage": task.progress_percentage,
            "estimated_hours": task.estimated_hours,
            "actual_hours": task.actual_hours
        })
    
    # Save backup
    backup_dir = f"/app/backups/{datetime.now().strftime('%Y/%m')}"
    os.makedirs(backup_dir, exist_ok=True)
    backup_file = f"{backup_dir}/backup_{backup_type}_{timestamp}.json"
    
    with open(backup_file, 'w') as f:
        json.dump(backup_data, f, indent=2, default=str)
    
    # Record backup
    backup_record = BackupRecord(
        backup_type=backup_type,
        file_path=backup_file,
        file_size=os.path.getsize(backup_file)
    )
    db.add(backup_record)
    db.commit()
    
    return {"message": f"{backup_type} backup created successfully", "file_path": backup_file}

def create_audit_log(db: Session, user_id: Optional[int], action: str, resource_type: str, 
                    resource_id: Optional[int], old_values: Optional[dict], new_values: Optional[dict]):
    audit_log = AuditLog(
        user_id=user_id,
        action=action,
        resource_type=resource_type,
        resource_id=resource_id,
        old_values=old_values,
        new_values=new_values,
        ip_address="127.0.0.1"  # TODO: Get actual IP
    )
    db.add(audit_log)
    db.commit()

# Docker Compose configuration
# docker-compose.yml
version: '3.8'

services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: team_bioinfo_db
      POSTGRES_USER: bioinfo_user
      POSTGRES_PASSWORD: bioinfo_pass
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/app/backups
    ports:
      - "5432:5432"
    networks:
      - bioinfo_network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    networks:
      - bioinfo_network

  api:
    build: .
    environment:
      DATABASE_URL: postgresql://bioinfo_user:bioinfo_pass@postgres:5432/team_bioinfo_db
      REDIS_URL: redis://redis:6379
    volumes:
      - ./exports:/app/exports
      - ./backups:/app/backups
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
    networks:
      - bioinfo_network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - api
    networks:
      - bioinfo_network

volumes:
  postgres_data:

networks:
  bioinfo_network:
    driver: bridge

# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN mkdir -p /app/exports /app/backups

EXPOSE 8000

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream api {
        server api:8000;
    }

    server {
        listen 80;
        server_name localhost;

        location / {
            proxy_pass http://api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        location /exports/ {
            alias /app/exports/;
            internal;
        }
    }
}

# Environment variables (.env)
DATABASE_URL=postgresql://bioinfo_user:bioinfo_pass@localhost:5432/team_bioinfo_db
SECRET_KEY=your-super-secret-key-change-this-in-production
REDIS_URL=redis://localhost:6379
BACKUP_RETENTION_DAYS=730
EXPORT_PATH=/app/exports
BACKUP_PATH=/app/backups

# Automated backup script (backup_scheduler.py)
import schedule
import time
from datetime import datetime
from sqlalchemy.orm import Session
from database import SessionLocal
from crud import create_backup_crud

def run_daily_backup():
    db = SessionLocal()
    try:
        create_backup_crud(db, "daily")
        print(f"Daily backup completed at {datetime.now()}")
    except Exception as e:
        print(f"Backup failed: {e}")
    finally:
        db.close()

def run_weekly_backup():
    db = SessionLocal()
    try:
        create_backup_crud(db, "weekly")
        print(f"Weekly backup completed at {datetime.now()}")
    except Exception as e:
        print(f"Weekly backup failed: {e}")
    finally:
        db.close()

def run_monthly_backup():
    db = SessionLocal()
    try:
        create_backup_crud(db, "monthly")
        print(f"Monthly backup completed at {datetime.now()}")
    except Exception as e:
        print(f"Monthly backup failed: {e}")
    finally:
        db.close()

# Schedule backups
schedule.every().day.at("02:00").do(run_daily_backup)
schedule.every().sunday.at("03:00").do(run_weekly_backup)
schedule.every().month.do(run_monthly_backup)

if __name__ == "__main__":
    print("Backup scheduler started...")
    while True:
        schedule.run_pending()
        time.sleep(60)
